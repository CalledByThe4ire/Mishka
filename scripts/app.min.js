/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "209eaf93eb8d3daa4284"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _svg4everybody = __webpack_require__(1);
	
	var _svg4everybody2 = _interopRequireDefault(_svg4everybody);
	
	__webpack_require__(2);
	
	__webpack_require__(4);
	
	__webpack_require__(5);
	
	__webpack_require__(6);
	
	__webpack_require__(7);
	
	__webpack_require__(8);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	document.addEventListener('DOMContentLoaded', function () {
		(0, _svg4everybody2.default)();
	});

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(root, factory) {
	     true ? // AMD. Register as an anonymous module unless amdModuleId is set
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return root.svg4everybody = factory();
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == typeof module && module.exports ? // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like environments that support module.exports,
	    // like Node.
	    module.exports = factory() : root.svg4everybody = factory();
	}(this, function() {
	    /*! svg4everybody v2.1.4 | github.com/jonathantneal/svg4everybody */
	    function embed(parent, svg, target) {
	        // if the target exists
	        if (target) {
	            // create a document fragment to hold the contents of the target
	            var fragment = document.createDocumentFragment(), viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox");
	            // conditionally set the viewBox on the svg
	            viewBox && svg.setAttribute("viewBox", viewBox);
	            // copy the contents of the clone into the fragment
	            for (// clone the target
	            var clone = target.cloneNode(!0); clone.childNodes.length; ) {
	                fragment.appendChild(clone.firstChild);
	            }
	            // append the fragment into the svg
	            parent.appendChild(fragment);
	        }
	    }
	    function loadreadystatechange(xhr) {
	        // listen to changes in the request
	        xhr.onreadystatechange = function() {
	            // if the request is ready
	            if (4 === xhr.readyState) {
	                // get the cached html document
	                var cachedDocument = xhr._cachedDocument;
	                // ensure the cached html document based on the xhr response
	                cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), 
	                cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}), // clear the xhr embeds list and embed each item
	                xhr._embeds.splice(0).map(function(item) {
	                    // get the cached target
	                    var target = xhr._cachedTarget[item.id];
	                    // ensure the cached target
	                    target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)), 
	                    // embed the target into the svg
	                    embed(item.parent, item.svg, target);
	                });
	            }
	        }, // test the ready state change immediately
	        xhr.onreadystatechange();
	    }
	    function svg4everybody(rawopts) {
	        function oninterval() {
	            // while the index exists in the live <use> collection
	            for (// get the cached <use> index
	            var index = 0; index < uses.length; ) {
	                // get the current <use>
	                var use = uses[index], parent = use.parentNode, svg = getSVGAncestor(parent);
	                if (svg) {
	                    var src = use.getAttribute("xlink:href") || use.getAttribute("href");
	                    if (polyfill && (!opts.validate || opts.validate(src, svg, use))) {
	                        // remove the <use> element
	                        parent.removeChild(use);
	                        // parse the src and get the url and id
	                        var srcSplit = src.split("#"), url = srcSplit.shift(), id = srcSplit.join("#");
	                        // if the link is external
	                        if (url.length) {
	                            // get the cached xhr request
	                            var xhr = requests[url];
	                            // ensure the xhr request exists
	                            xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), 
	                            xhr._embeds = []), // add the svg and id as an item to the xhr embeds list
	                            xhr._embeds.push({
	                                parent: parent,
	                                svg: svg,
	                                id: id
	                            }), // prepare the xhr ready state change event
	                            loadreadystatechange(xhr);
	                        } else {
	                            // embed the local id into the svg
	                            embed(parent, document.getElementById(id));
	                        }
	                    }
	                } else {
	                    // increase the index when the previous value was not "valid"
	                    ++index;
	                }
	            }
	            // continue the interval
	            requestAnimationFrame(oninterval, 67);
	        }
	        var polyfill, opts = Object(rawopts), newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/, webkitUA = /\bAppleWebKit\/(\d+)\b/, olderEdgeUA = /\bEdge\/12\.(\d+)\b/;
	        polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537;
	        // create xhr requests object
	        var requests = {}, requestAnimationFrame = window.requestAnimationFrame || setTimeout, uses = document.getElementsByTagName("use");
	        // conditionally start the interval if the polyfill is active
	        polyfill && oninterval();
	    }
	    function getSVGAncestor(node) {
	        for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode); ) {}
	        return svg;
	    }
	    return svg4everybody;
	});

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _lory = __webpack_require__(3);
	
	exports.default = window.addEventListener('DOMContentLoaded', function () {
	
		var slider = document.querySelector('.js_slider');
	
		if (slider) {
	
			(0, _lory.lory)(slider, {
				slideSpeed: 600,
				rewind: true,
				rewindSpeed: 1200
			});
		}
	});

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else {
			var a = factory();
			for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
		}
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* globals jQuery */
		
		exports.lory = lory;
		
		var _detectPrefixes = __webpack_require__(2);
		
		var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);
		
		var _dispatchEvent = __webpack_require__(3);
		
		var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);
		
		var _defaults = __webpack_require__(5);
		
		var _defaults2 = _interopRequireDefault(_defaults);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var slice = Array.prototype.slice;
		
		function lory(slider, opts) {
		    var position = void 0;
		    var slidesWidth = void 0;
		    var frameWidth = void 0;
		    var slides = void 0;
		
		    /**
		     * slider DOM elements
		     */
		    var frame = void 0;
		    var slideContainer = void 0;
		    var prevCtrl = void 0;
		    var nextCtrl = void 0;
		    var prefixes = void 0;
		    var transitionEndCallback = void 0;
		
		    var index = 0;
		    var options = {};
		
		    /**
		     * if object is jQuery convert to native DOM element
		     */
		    if (typeof jQuery !== 'undefined' && slider instanceof jQuery) {
		        slider = slider[0];
		    }
		
		    /**
		     * private
		     * set active class to element which is the current slide
		     */
		    function setActiveElement(slides, currentIndex) {
		        var _options = options;
		        var classNameActiveSlide = _options.classNameActiveSlide;
		
		
		        slides.forEach(function (element, index) {
		            if (element.classList.contains(classNameActiveSlide)) {
		                element.classList.remove(classNameActiveSlide);
		            }
		        });
		
		        slides[currentIndex].classList.add(classNameActiveSlide);
		    }
		
		    /**
		     * private
		     * setupInfinite: function to setup if infinite is set
		     *
		     * @param  {array} slideArray
		     * @return {array} array of updated slideContainer elements
		     */
		    function setupInfinite(slideArray) {
		        var _options2 = options;
		        var infinite = _options2.infinite;
		
		
		        var front = slideArray.slice(0, infinite);
		        var back = slideArray.slice(slideArray.length - infinite, slideArray.length);
		
		        front.forEach(function (element) {
		            var cloned = element.cloneNode(true);
		
		            slideContainer.appendChild(cloned);
		        });
		
		        back.reverse().forEach(function (element) {
		            var cloned = element.cloneNode(true);
		
		            slideContainer.insertBefore(cloned, slideContainer.firstChild);
		        });
		
		        slideContainer.addEventListener(prefixes.transitionEnd, onTransitionEnd);
		
		        return slice.call(slideContainer.children);
		    }
		
		    /**
		     * [dispatchSliderEvent description]
		     * @return {[type]} [description]
		     */
		    function dispatchSliderEvent(phase, type, detail) {
		        (0, _dispatchEvent2.default)(slider, phase + '.lory.' + type, detail);
		    }
		
		    /**
		     * translates to a given position in a given time in milliseconds
		     *
		     * @to        {number} number in pixels where to translate to
		     * @duration  {number} time in milliseconds for the transistion
		     * @ease      {string} easing css property
		     */
		    function translate(to, duration, ease) {
		        var style = slideContainer && slideContainer.style;
		
		        if (style) {
		            style[prefixes.transition + 'TimingFunction'] = ease;
		            style[prefixes.transition + 'Duration'] = duration + 'ms';
		
		            if (prefixes.hasTranslate3d) {
		                style[prefixes.transform] = 'translate3d(' + to + 'px, 0, 0)';
		            } else {
		                style[prefixes.transform] = 'translate(' + to + 'px, 0)';
		            }
		        }
		    }
		
		    /**
		     * slidefunction called by prev, next & touchend
		     *
		     * determine nextIndex and slide to next postion
		     * under restrictions of the defined options
		     *
		     * @direction  {boolean}
		     */
		    function slide(nextIndex, direction) {
		        var _options3 = options;
		        var slideSpeed = _options3.slideSpeed;
		        var slidesToScroll = _options3.slidesToScroll;
		        var infinite = _options3.infinite;
		        var rewind = _options3.rewind;
		        var rewindSpeed = _options3.rewindSpeed;
		        var ease = _options3.ease;
		        var classNameActiveSlide = _options3.classNameActiveSlide;
		
		
		        var duration = slideSpeed;
		
		        var nextSlide = direction ? index + 1 : index - 1;
		        var maxOffset = Math.round(slidesWidth - frameWidth);
		
		        dispatchSliderEvent('before', 'slide', {
		            index: index,
		            nextSlide: nextSlide
		        });
		
		        if (typeof nextIndex !== 'number') {
		            if (direction) {
		                nextIndex = index + slidesToScroll;
		            } else {
		                nextIndex = index - slidesToScroll;
		            }
		        }
		
		        nextIndex = Math.min(Math.max(nextIndex, 0), slides.length - 1);
		
		        if (infinite && direction === undefined) {
		            nextIndex += infinite;
		        }
		
		        var nextOffset = Math.min(Math.max(slides[nextIndex].offsetLeft * -1, maxOffset * -1), 0);
		
		        if (rewind && Math.abs(position.x) === maxOffset && direction) {
		            nextOffset = 0;
		            nextIndex = 0;
		            duration = rewindSpeed;
		        }
		
		        /**
		         * translate to the nextOffset by a defined duration and ease function
		         */
		        translate(nextOffset, duration, ease);
		
		        /**
		         * update the position with the next position
		         */
		        position.x = nextOffset;
		
		        /**
		         * update the index with the nextIndex only if
		         * the offset of the nextIndex is in the range of the maxOffset
		         */
		        if (slides[nextIndex].offsetLeft <= maxOffset) {
		            index = nextIndex;
		        }
		
		        if (infinite && (nextIndex === slides.length - infinite || nextIndex === 0)) {
		            if (direction) {
		                index = infinite;
		            }
		
		            if (!direction) {
		                index = slides.length - infinite * 2;
		            }
		
		            position.x = slides[index].offsetLeft * -1;
		
		            transitionEndCallback = function transitionEndCallback() {
		                translate(slides[index].offsetLeft * -1, 0, undefined);
		            };
		        }
		
		        if (classNameActiveSlide) {
		            setActiveElement(slice.call(slides), index);
		        }
		
		        dispatchSliderEvent('after', 'slide', {
		            currentSlide: index
		        });
		    }
		
		    /**
		     * public
		     * setup function
		     */
		    function setup() {
		        dispatchSliderEvent('before', 'init');
		
		        prefixes = (0, _detectPrefixes2.default)();
		        options = _extends({}, _defaults2.default, opts);
		
		        var _options4 = options;
		        var classNameFrame = _options4.classNameFrame;
		        var classNameSlideContainer = _options4.classNameSlideContainer;
		        var classNamePrevCtrl = _options4.classNamePrevCtrl;
		        var classNameNextCtrl = _options4.classNameNextCtrl;
		        var enableMouseEvents = _options4.enableMouseEvents;
		        var classNameActiveSlide = _options4.classNameActiveSlide;
		
		
		        frame = slider.getElementsByClassName(classNameFrame)[0];
		        slideContainer = frame.getElementsByClassName(classNameSlideContainer)[0];
		        prevCtrl = slider.getElementsByClassName(classNamePrevCtrl)[0];
		        nextCtrl = slider.getElementsByClassName(classNameNextCtrl)[0];
		
		        position = {
		            x: slideContainer.offsetLeft,
		            y: slideContainer.offsetTop
		        };
		
		        if (options.infinite) {
		            slides = setupInfinite(slice.call(slideContainer.children));
		        } else {
		            slides = slice.call(slideContainer.children);
		        }
		
		        reset();
		
		        if (classNameActiveSlide) {
		            setActiveElement(slides, index);
		        }
		
		        if (prevCtrl && nextCtrl) {
		            prevCtrl.addEventListener('click', prev);
		            nextCtrl.addEventListener('click', next);
		        }
		
		        frame.addEventListener('touchstart', onTouchstart);
		
		        if (enableMouseEvents) {
		            frame.addEventListener('mousedown', onTouchstart);
		            frame.addEventListener('click', onClick);
		        }
		
		        options.window.addEventListener('resize', onResize);
		
		        dispatchSliderEvent('after', 'init');
		    }
		
		    /**
		     * public
		     * reset function: called on resize
		     */
		    function reset() {
		        var _options5 = options;
		        var infinite = _options5.infinite;
		        var ease = _options5.ease;
		        var rewindSpeed = _options5.rewindSpeed;
		        var rewindOnResize = _options5.rewindOnResize;
		        var classNameActiveSlide = _options5.classNameActiveSlide;
		
		
		        slidesWidth = slideContainer.getBoundingClientRect().width || slideContainer.offsetWidth;
		        frameWidth = frame.getBoundingClientRect().width || frame.offsetWidth;
		
		        if (frameWidth === slidesWidth) {
		            slidesWidth = slides.reduce(function (previousValue, slide) {
		                return previousValue + slide.getBoundingClientRect().width || slide.offsetWidth;
		            }, 0);
		        }
		
		        if (rewindOnResize) {
		            index = 0;
		        } else {
		            ease = null;
		            rewindSpeed = 0;
		        }
		
		        if (infinite) {
		            translate(slides[index + infinite].offsetLeft * -1, 0, null);
		
		            index = index + infinite;
		            position.x = slides[index].offsetLeft * -1;
		        } else {
		            translate(slides[index].offsetLeft * -1, rewindSpeed, ease);
		            position.x = slides[index].offsetLeft * -1;
		        }
		
		        if (classNameActiveSlide) {
		            setActiveElement(slice.call(slides), index);
		        }
		    }
		
		    /**
		     * public
		     * slideTo: called on clickhandler
		     */
		    function slideTo(index) {
		        slide(index);
		    }
		
		    /**
		     * public
		     * returnIndex function: called on clickhandler
		     */
		    function returnIndex() {
		        return index - options.infinite || 0;
		    }
		
		    /**
		     * public
		     * prev function: called on clickhandler
		     */
		    function prev() {
		        slide(false, false);
		    }
		
		    /**
		     * public
		     * next function: called on clickhandler
		     */
		    function next() {
		        slide(false, true);
		    }
		
		    /**
		     * public
		     * destroy function: called to gracefully destroy the lory instance
		     */
		    function destroy() {
		        dispatchSliderEvent('before', 'destroy');
		
		        // remove event listeners
		        frame.removeEventListener(prefixes.transitionEnd, onTransitionEnd);
		        frame.removeEventListener('touchstart', onTouchstart);
		        frame.removeEventListener('touchmove', onTouchmove);
		        frame.removeEventListener('touchend', onTouchend);
		        frame.removeEventListener('mousemove', onTouchmove);
		        frame.removeEventListener('mousedown', onTouchstart);
		        frame.removeEventListener('mouseup', onTouchend);
		        frame.removeEventListener('mouseleave', onTouchend);
		        frame.removeEventListener('click', onClick);
		
		        options.window.removeEventListener('resize', onResize);
		
		        if (prevCtrl) {
		            prevCtrl.removeEventListener('click', prev);
		        }
		
		        if (nextCtrl) {
		            nextCtrl.removeEventListener('click', next);
		        }
		
		        // remove cloned slides if infinite is set
		        if (options.infinite) {
		            Array.apply(null, Array(options.infinite)).forEach(function () {
		                slideContainer.removeChild(slideContainer.firstChild);
		                slideContainer.removeChild(slideContainer.lastChild);
		            });
		        }
		
		        dispatchSliderEvent('after', 'destroy');
		    }
		
		    // event handling
		
		    var touchOffset = void 0;
		    var delta = void 0;
		    var isScrolling = void 0;
		
		    function onTransitionEnd() {
		        if (transitionEndCallback) {
		            transitionEndCallback();
		
		            transitionEndCallback = undefined;
		        }
		    }
		
		    function onTouchstart(event) {
		        var _options6 = options;
		        var enableMouseEvents = _options6.enableMouseEvents;
		
		        var touches = event.touches ? event.touches[0] : event;
		
		        if (enableMouseEvents) {
		            frame.addEventListener('mousemove', onTouchmove);
		            frame.addEventListener('mouseup', onTouchend);
		            frame.addEventListener('mouseleave', onTouchend);
		        }
		
		        frame.addEventListener('touchmove', onTouchmove);
		        frame.addEventListener('touchend', onTouchend);
		
		        var pageX = touches.pageX;
		        var pageY = touches.pageY;
		
		
		        touchOffset = {
		            x: pageX,
		            y: pageY,
		            time: Date.now()
		        };
		
		        isScrolling = undefined;
		
		        delta = {};
		
		        dispatchSliderEvent('on', 'touchstart', {
		            event: event
		        });
		    }
		
		    function onTouchmove(event) {
		        var touches = event.touches ? event.touches[0] : event;
		        var pageX = touches.pageX;
		        var pageY = touches.pageY;
		
		
		        delta = {
		            x: pageX - touchOffset.x,
		            y: pageY - touchOffset.y
		        };
		
		        if (typeof isScrolling === 'undefined') {
		            isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
		        }
		
		        if (!isScrolling && touchOffset) {
		            event.preventDefault();
		            translate(position.x + delta.x, 0, null);
		        }
		
		        // may be
		        dispatchSliderEvent('on', 'touchmove', {
		            event: event
		        });
		    }
		
		    function onTouchend(event) {
		        /**
		         * time between touchstart and touchend in milliseconds
		         * @duration {number}
		         */
		        var duration = touchOffset ? Date.now() - touchOffset.time : undefined;
		
		        /**
		         * is valid if:
		         *
		         * -> swipe attempt time is over 300 ms
		         * and
		         * -> swipe distance is greater than 25px
		         * or
		         * -> swipe distance is more then a third of the swipe area
		         *
		         * @isValidSlide {Boolean}
		         */
		        var isValid = Number(duration) < 300 && Math.abs(delta.x) > 25 || Math.abs(delta.x) > frameWidth / 3;
		
		        /**
		         * is out of bounds if:
		         *
		         * -> index is 0 and delta x is greater than 0
		         * or
		         * -> index is the last slide and delta is smaller than 0
		         *
		         * @isOutOfBounds {Boolean}
		         */
		        var isOutOfBounds = !index && delta.x > 0 || index === slides.length - 1 && delta.x < 0;
		
		        var direction = delta.x < 0;
		
		        if (!isScrolling) {
		            if (isValid && !isOutOfBounds) {
		                slide(false, direction);
		            } else {
		                translate(position.x, options.snapBackSpeed);
		            }
		        }
		
		        touchOffset = undefined;
		
		        /**
		         * remove eventlisteners after swipe attempt
		         */
		        frame.removeEventListener('touchmove', onTouchmove);
		        frame.removeEventListener('touchend', onTouchend);
		        frame.removeEventListener('mousemove', onTouchmove);
		        frame.removeEventListener('mouseup', onTouchend);
		        frame.removeEventListener('mouseleave', onTouchend);
		
		        dispatchSliderEvent('on', 'touchend', {
		            event: event
		        });
		    }
		
		    function onClick(event) {
		        if (delta.x) {
		            event.preventDefault();
		        }
		    }
		
		    function onResize(event) {
		        reset();
		
		        dispatchSliderEvent('on', 'resize', {
		            event: event
		        });
		    }
		
		    // trigger initial setup
		    setup();
		
		    // expose public api
		    return {
		        setup: setup,
		        reset: reset,
		        slideTo: slideTo,
		        returnIndex: returnIndex,
		        prev: prev,
		        next: next,
		        destroy: destroy
		    };
		}
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = detectPrefixes;
		/**
		 * Detecting prefixes for saving time and bytes
		 */
		function detectPrefixes() {
		    var transform = void 0;
		    var transition = void 0;
		    var transitionEnd = void 0;
		    var hasTranslate3d = void 0;
		
		    (function () {
		        var el = document.createElement('_');
		        var style = el.style;
		
		        var prop = void 0;
		
		        if (style[prop = 'webkitTransition'] === '') {
		            transitionEnd = 'webkitTransitionEnd';
		            transition = prop;
		        }
		
		        if (style[prop = 'transition'] === '') {
		            transitionEnd = 'transitionend';
		            transition = prop;
		        }
		
		        if (style[prop = 'webkitTransform'] === '') {
		            transform = prop;
		        }
		
		        if (style[prop = 'msTransform'] === '') {
		            transform = prop;
		        }
		
		        if (style[prop = 'transform'] === '') {
		            transform = prop;
		        }
		
		        document.body.insertBefore(el, null);
		        style[transform] = 'translate3d(0, 0, 0)';
		        hasTranslate3d = !!global.getComputedStyle(el).getPropertyValue(transform);
		        document.body.removeChild(el);
		    })();
		
		    return {
		        transform: transform,
		        transition: transition,
		        transitionEnd: transitionEnd,
		        hasTranslate3d: hasTranslate3d
		    };
		}
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = dispatchEvent;
		
		var _customEvent = __webpack_require__(4);
		
		var _customEvent2 = _interopRequireDefault(_customEvent);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		/**
		 * dispatch custom events
		 *
		 * @param  {element} el         slideshow element
		 * @param  {string}  type       custom event name
		 * @param  {object}  detail     custom detail information
		 */
		function dispatchEvent(target, type, detail) {
		    var event = new _customEvent2.default(type, {
		        bubbles: true,
		        cancelable: true,
		        detail: detail
		    });
		
		    target.dispatchEvent(event);
		}
	
	/***/ },
	/* 4 */
	/***/ function(module, exports) {
	
		/* WEBPACK VAR INJECTION */(function(global) {
		var NativeCustomEvent = global.CustomEvent;
		
		function useNative () {
		  try {
		    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
		    return  'cat' === p.type && 'bar' === p.detail.foo;
		  } catch (e) {
		  }
		  return false;
		}
		
		/**
		 * Cross-browser `CustomEvent` constructor.
		 *
		 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
		 *
		 * @public
		 */
		
		module.exports = useNative() ? NativeCustomEvent :
		
		// IE >= 9
		'function' === typeof document.createEvent ? function CustomEvent (type, params) {
		  var e = document.createEvent('CustomEvent');
		  if (params) {
		    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
		  } else {
		    e.initCustomEvent(type, false, false, void 0);
		  }
		  return e;
		} :
		
		// IE <= 8
		function CustomEvent (type, params) {
		  var e = document.createEventObject();
		  e.type = type;
		  if (params) {
		    e.bubbles = Boolean(params.bubbles);
		    e.cancelable = Boolean(params.cancelable);
		    e.detail = params.detail;
		  } else {
		    e.bubbles = false;
		    e.cancelable = false;
		    e.detail = void 0;
		  }
		  return e;
		}
		
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = {
		  /**
		   * slides scrolled at once
		   * @slidesToScroll {Number}
		   */
		  slidesToScroll: 1,
		
		  /**
		   * time in milliseconds for the animation of a valid slide attempt
		   * @slideSpeed {Number}
		   */
		  slideSpeed: 300,
		
		  /**
		   * time in milliseconds for the animation of the rewind after the last slide
		   * @rewindSpeed {Number}
		   */
		  rewindSpeed: 600,
		
		  /**
		   * time for the snapBack of the slider if the slide attempt was not valid
		   * @snapBackSpeed {Number}
		   */
		  snapBackSpeed: 200,
		
		  /**
		   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
		   * cubic bezier easing functions: http://easings.net/de
		   * @ease {String}
		   */
		  ease: 'ease',
		
		  /**
		   * if slider reached the last slide, with next click the slider goes back to the startindex.
		   * use infinite or rewind, not both
		   * @rewind {Boolean}
		   */
		  rewind: false,
		
		  /**
		   * number of visible slides or false
		   * use infinite or rewind, not both
		   * @infinite {number}
		   */
		  infinite: false,
		
		  /**
		   * class name for slider frame
		   * @classNameFrame {string}
		   */
		  classNameFrame: 'js_frame',
		
		  /**
		   * class name for slides container
		   * @classNameSlideContainer {string}
		   */
		  classNameSlideContainer: 'js_slides',
		
		  /**
		   * class name for slider prev control
		   * @classNamePrevCtrl {string}
		   */
		  classNamePrevCtrl: 'js_prev',
		
		  /**
		   * class name for slider next control
		   * @classNameNextCtrl {string}
		   */
		  classNameNextCtrl: 'js_next',
		
		  /**
		   * class name for current active slide
		   * if emptyString then no class is set
		   * @classNameActiveSlide {string}
		   */
		  classNameActiveSlide: 'active',
		
		  /**
		   * enables mouse events for swiping on desktop devices
		   * @enableMouseEvents {boolean}
		   */
		  enableMouseEvents: false,
		
		  /**
		   * window instance
		   * @window {object}
		   */
		  window: window,
		
		  /**
		   * If false, slides lory to the first slide on window resize.
		   * @rewindOnResize {boolean}
		   */
		  rewindOnResize: true
		};
	
	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = window.addEventListener('DOMContentLoaded', function () {
	
		var mqlMobile = window.matchMedia('only screen and (max-width: 767px)');
		var mqlTabDesk = window.matchMedia('only screen and (min-width: 768px)');
		var mqlTablet = window.matchMedia('only screen and (min-width: 768px) and (max-width: 1149px)');
		var mqlDesktop = window.matchMedia('only screen and (min-width: 1150px)');
	
		var nav = document.querySelector('.js_nav');
		var logo = document.querySelector('.js_logo');
		var icon = document.querySelector('.icon');
	
		var iconPath = '/assets/images/icon.svg#icon_nav-toggle-';
		var openMod = 'open';
		var closeMod = 'close';
		var visibleMod = 'visible';
	
		/**
	  * Скрывает / отображает навигационные ссылки
	  * для мобильной версии сайта
	  * @param {MouseEvent} evt
	  */
		var toggleNav = function toggleNav(evt) {
			evt.target.classList.toggle('icon--' + closeMod);
			nav.classList.toggle('nav--' + visibleMod);
	
			if (!nav.classList.contains('nav--' + visibleMod)) {
				icon.classList.add('icon--' + openMod);
				icon.firstElementChild.setAttribute('xlink:href', iconPath + openMod);
			} else {
				icon.classList.remove('icon--' + openMod);
				icon.firstElementChild.setAttribute('xlink:href', iconPath + closeMod);
			}
		};
	
		/**
	  * Меняет атрибуты у логотипа
	  * для каждой из ширин viewport'а
	  * @param {String} width
	  * @param {String} height
	  * @param {String} name
	  */
		var setLogo = function setLogo(width, height, name) {
			var iconLogoPath = '/assets/images/icon.svg#icon_';
			logo.classList = 'logo js_logo logo--' + name;
			logo.setAttribute('width', width);
			logo.setAttribute('height', height);
			logo.querySelector('use').setAttribute('xlink:href', iconLogoPath + 'logo-' + name);
		};
	
		/**
	  * Меняет значение атрибута в зависимости от размера окна браузера
	  */
		var matchMedia = function matchMedia() {
			if (mqlTabDesk.matches) {
				if (!nav.classList.contains('nav--' + visibleMod)) {
					nav.classList.add('nav--' + visibleMod);
				}
			}
	
			if (mqlMobile.matches) {
				setLogo('86px', '35px', 'mobile');
	
				if (icon.classList.contains('icon--' + openMod)) {
					nav.classList.remove('nav--' + visibleMod);
				}
			}
	
			if (mqlTablet.matches) {
				setLogo('114px', '48px', 'tablet');
			}
	
			if (mqlDesktop.matches) {
				setLogo('150px', '74px', 'desktop');
			}
		};
	
		icon.addEventListener('click', function (evt) {
			toggleNav(evt);
		});
	
		matchMedia();
	
		window.addEventListener('resize', function () {
			matchMedia();
		});
	});

/***/ },
/* 5 */
/***/ function(module, exports) {

	/* global google */
	
	'use strict';
	
	/**
	 * Google Maps
	 */
	
	window.initMap = function () {
		var LatLng = { lat: 59.9387942, lng: 30.3230833 };
		var mapOptions = {
			zoom: 15,
			center: LatLng
		};
	
		var isIE11 = !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));
	
		var map = new google.maps.Map(document.querySelector('.js_map'), mapOptions);
	
		var markerImage = {
			url: isIE11 ? '/assets/images/map-pin.png' : '/assets/images/map-pin.svg',
			size: new google.maps.Size(100, 100),
			origin: new google.maps.Point(0, 0),
			anchor: new google.maps.Point(20, 20),
			optimized: false,
			zIndex: 1
		};
	
		var marker = new google.maps.Marker({
			position: LatLng,
			map: map,
			icon: markerImage,
			title: 'HTML Academy'
		});
	
		google.maps.event.addDomListener(window, 'resize', function () {
			var center = map.getCenter();
			google.maps.event.trigger(map, 'resize');
			map.setCenter(center);
		});
	
		marker.setMap(map);
	};

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = window.addEventListener('DOMContentLoaded', function () {
	
		var mqlMobile = window.matchMedia('only screen and (max-width: 767px)');
		var mqlTabDesk = window.matchMedia('only screen and (min-width: 768px)');
	
		var intro = document.querySelector('.page--form .intro > p');
	
		/**
	  * Меняет значение атрибута в зависимости от размера окна браузера
	  */
		var matchMedia = function matchMedia() {
			if (intro) {
				if (mqlMobile.matches) {
					intro.innerHTML = 'Мы будем рады воплотить в жизнь ваши пожелания! Заполните простую форму заказа, и мы свяжемся с вами, чтобы уточнить детали.';
				}
	
				if (mqlTabDesk.matches) {
					intro.innerHTML = 'Мы будем рады воплотить в жизнь ваши пожелания!<br>Заполните простую форму заказа и' + ' мы свяжемся с вами, чтобы уточнить детали.';
				}
			}
		};
	
		matchMedia();
	
		window.addEventListener('resize', function () {
			matchMedia();
		});
	});

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = window.addEventListener('DOMContentLoaded', function () {
	
		var textField = Array.prototype.slice.call(document.querySelectorAll('.text-field .text-field__input'));
		var email = document.querySelector('input[type=\'email\']');
	
		var mqlMobile = window.matchMedia('only screen and (max-width: 767px)');
		var mqlTabDesk = window.matchMedia('only screen and (min-width: 768px)');
	
		/**
	  * Добавляет / убирает класс у элемента,
	  * который является родителем для поля ввода
	  * @param {MouseEvent} evt
	  */
		var toggleFocus = function toggleFocus(evt) {
			if (evt.target === document.activeElement) {
				evt.target.parentElement.classList.add('text-field__container--focus');
			} else {
				evt.target.parentElement.classList.remove('text-field__container--focus');
			}
		};
	
		/**
	  * Меняет значение атрибута в зависимости от размера окна браузера
	  */
		var matchMedia = function matchMedia() {
			if (email) {
				if (mqlMobile.matches) {
					email.setAttribute('placeholder', 'Ваш e-mail');
				}
	
				if (mqlTabDesk.matches) {
					email.setAttribute('placeholder', 'Мы не будем спамить, честно!');
				}
			}
		};
	
		if (textField) {
			textField.forEach(function (el) {
				'focus blur'.split(' ').forEach(function (evt) {
					return el.addEventListener(evt, toggleFocus);
				});
			});
		}
	
		matchMedia();
	
		window.addEventListener('resize', function () {
			matchMedia();
		});
	});

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = window.addEventListener('DOMContentLoaded', function () {
	
		var mqlMobile = window.matchMedia('only screen and (max-width: 767px)');
		var mqlTablet = window.matchMedia('only screen and (min-width: 768px) and (max-width: 1149px)');
		var mqlDesktop = window.matchMedia('only screen and (min-width: 1150px)');
	
		/**
	  * Настройки для проигрывания видео
	  */
		var setupVideo = function setupVideo() {
	
			var video = document.querySelector('.js_video');
			var play = document.querySelector('.js_play');
	
			/**
	   * Меняет значение атрибута в зависимости от размера окна браузера
	   */
			var matchMedia = function matchMedia() {
				if (mqlMobile.matches) {
					video.setAttribute('poster', 'assets/images/video-mobile@2x.png');
				}
	
				if (mqlTablet.matches) {
					video.setAttribute('poster', 'assets/images/video-tablet.png');
				}
	
				if (mqlDesktop.matches) {
					video.setAttribute('poster', 'assets/images/video-desktop.png');
				}
			};
	
			if (video && play) {
				if (video.canPlayType) {
					video.removeAttribute('controls');
					document.querySelector('.js_video__controls').style.display = 'block';
	
					video.addEventListener('ended', function () {
						play.disabled = false;
						play.style.display = 'block';
					}, false);
	
					video.addEventListener('play', function () {
						play.disabled = true;
						play.style.display = 'none';
					}, false);
	
					play.addEventListener('click', function () {
						video.play();
					}, false);
	
					matchMedia();
	
					window.addEventListener('resize', function () {
						matchMedia();
					});
				}
			}
		};
	
		setupVideo();
	});

/***/ }
/******/ ]);
//# sourceMappingURL=app.min.js.map